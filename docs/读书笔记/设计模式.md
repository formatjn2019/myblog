# 设计模式

## 使用方式

### 大致浏览一遍模式

- 特别其适用性部分适合你的问题

### 回头研究结果部分、参与者部分和协作部分

- 确保你理解这个模式的类和对象以及它们是怎样关联的

### 看代码的示例部分，看看这个模式代码形成的具体例子

- 研究代码将有助于你实现设计模式

### 选择模式参与者的名字，使它们在应用上下文中有意义

- 设计模式参与者的名字通常过于抽象而不会直接出现在应用中。
- 然而，将参与者的名字和应用中出现的名字合并起来是很有用的。这会帮助你在实现中更显式的体现出模式来。

### 定义类

- 声明它们的接口，建立它们的继承关系，定义代表数据和对象引用的实例变量。
- 识别模式会影响到的你的应用中存在的类，做出相应的修改。

### 定义模式中专用与应用的操作名称

- 这里再一次体现出，名字一般依赖于应用。使用与每一个操作相关联的责任和协作作为指导。
- 还有，你的名字约定要一致。例如可以使用“Create”前缀统一标记Factory方法。

### 实现执行模式中责任和协作的操作

- 实现部分提供线索指导你进行实现。代码实例部分的例子也能提供帮助。

## 创建型模式

### 简单工厂

- 简单工厂是一个设计模式，而是一种编程习惯。
- 常被误认为是工厂模式。

### ABSTRACT FACTORY(抽象工厂)

- 意图

	- 提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。

- 别名

	- Kit

- 动机

	- 客户仅与抽象类定义的接口交互，而不使用特定的具体类的接口。

- 适用性

	- 一个系统要独立于它的产品的创建，组合和表示时。
	- 一个系统要由多个产品系列中的一个来配置时。
	- 当你强调一系列相关的产品对象的设计以便进行联合使用时。
	- 当你提供以产品类库，而只想显示它们的接口而不是实现时。

- 结构

	- 

- 参与者

	- AbstractFactory

		- 声明一个创建抽象产品对象的操作接口

	- ConcreteFactory

		- 实现创建具体产品对象的操作

	- AbstractProduct

		- 为一类产品对象声明一个接口

	- ConcreteProduct

		- 定义一个将被相应的具体工厂创建的产品对象
		- 实现AbstractProduct接口

	- Client

		- 仅使用由AbstractFactory和AbstractProduct类声明的接口

- 协作

	- 通常在运行时刻创建一个ConcreteFactroy类的实例。
	- 这一具体的工厂创建具有特定实现的产品对象。
	- 为创建不同的产品对象，客户应使用不同的具体工厂。

- 效果

	- 优点

		- 它分离了具体的类

			- Abstract Factory 模式帮助你控制一个应用创建的对象的类。因为一个工厂封装创建产品对象的责任和过程，它将客户与类的实现分离。
			- 客户通过它们的抽象接口操纵实例。产品的类名也在具体工厂的实现中被分离；它们不出现在客户代码中。

		- 它使得易于交换产品系列

			- 一个具体工厂类在一个应用中仅出现一次——即在它初始化的时候。这使得改变一个应用的具体工厂变得很容易。
			- 它只需改变具体的工厂即可使用不同的产品配置，这是因为一个抽象工厂创建了一个完整的产品系列，所以整个产品系列就会立即改变。

		- 它利于产品的一致性

			- 当一个系列中的产品对象被设计成一起工作时，一个应用一次只能使用同一个系列中的对象，这一点很重要。而AbstractFactory很容易实现这一点。

	- 缺点

		- 难以支持新种类的产品

			- 难以扩展抽象工厂以生产新种类的产品。
			- 这是因为AbstractFactory接口确定类可以被创建的产品集合。支持新种类的产品就需要扩展该工厂接口，这将设计AbstractFactory类机器所有子类的改变。

- 实现

	- 将工程作为单件

		- 一个应用中一般每个产品系列只需一个ConcreateFactory实例。因此工厂通常最好实现为一个Singleton

	- 创建产品

		- AbstractFactory仅声明一个创建产品的接口，真正创建产品是由ConcreteProduct子类实现的。最通常的一个办法是为每一个产品定义一个工厂方法。
		- 一个具体的工厂将为每个产品重定义该工厂方法以指定产品。虽然这样的实现很简单，但它要求每个产品系列都要有一个新的具体工厂子类，即使这些产品系列的差别很小。

	- 定义可扩展的工厂

		- AbstractFactory通常为每一种它可以生产的产品定义一个操作。产品的种类被编码在操作型构中。增加一种新的产品要求改变AbstractFactory的接口以及所有与它相关的类。
		- 一个更灵活但不太安全的设计是给创建对象的操作增加一个参数。该参数指定了将被创建的对象的种类。
		- 它可以是一个类标识符、一个整数、一个字符串或其他任何可以标识这种产品的东西。

### BUILDER(生成器)

- 意图

	- 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。

- 动机

	- 每种转换器类将创建和装配一个复杂对象的机制隐含在抽象接口后面。转换器独立于阅读器，阅读器负责对文档进行语法分析。
	- Builder模式中，转换器称为生成器，阅读器称为导向器。

- 适用性

	- 当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时。
	- 当构造过程必须允许被构造的对象有不同的表示时。

- 结构

	- 

- 参与者

	- Builder

		- 为创建一个Product对象的各个部件指定抽象接口

	- ConcreteBuilder

		- 实现Builder的接口以构造和装配该产品的各个部件
		- 定义并明确它所创建的表示
		- 提供一个检索产品的接口

	- Director

		- 构造一个使用Builder接口的对象

	- Product

		- 表示被构造的复杂对象。ConcreteBuilder创建该产品的内部表示并定义它的装配过程。
		- 包含定义组成部件的类，包括将这些装配成最终产品的接口。

- 协作

	- 客户创建Director对象，并用它所想要的Builder对象进行配置。
	- 一旦产品部件被生成，导向器就会通知生成器。
	- 客户从生成器中检索产品，并将部件添加到该产品中。
	- 客户从生成器中检索产品

- 效果

	- 它使你可以改变一个产品的内部表示

		- Builder对象提供给导向器一个构造产品的抽象接口。该接口使得生成器可以隐藏这个产品的表示和内部结构。它同时也隐藏了该产品是如何装配的。因为产品是通过抽象接口构造的，你在改变该产品的内部表示时要做的只是定义一个新的生成器。

	- 它将构造代码和表示代码分开

		- Builder模式通过封装一个复杂对象的创建和表示方式提高了对象的模块性。客户不需要知道定义产品内部结构的类的所有信息；这些类是不出现在Builder接口中的。
		- 每个ConcreteBuilder包含了创建和装配一个特定产品的所有代码。这些代码只需要写一次；
		- 然后不同的Director可以复用它以在相同部件集合的基础上构作不同的Product。

	- 它使你可对构造过程进行更精细的控制

		- Builder模式与已下载就生成产品的创建型模式不同，它是在导向者的控制下一步步构造产品的，仅当该产品完成时导向者才从生成器中取回它。因此Builder接口想不其他创建型模式能更好的泛型产品的构造过程。这是你可以更精细的控制构建过程，从而能更精细的控制所得的产品的内部结构。

- 实现

	- 通常有一个抽象的Builder类为导向者可能要求创建每一个构建定义一个操作。这些操作缺省情况下什么都不做。

		- 一个ConcreteBuilder类对它有兴趣创建的构建重定义这些操作。

	- 问题

		- 装配和构造接口

			- 生成器逐步的构造它们的产品，因此Builder类接口必须足够普通，以便为各种类型的具体生成器构造产品。

		- 为什么产品没有抽象类

			- 通常情况下，有具体生成器生成的产品，它们的表示相差是如此之大以至于给不同的产品以公共父类没有太大意思。

		- 在Builder中缺省的方法为空

			- 在C++中，生成方法故意不声明为纯虚成员函数，而是把它们定义为空方法，这使客户只重定义他们所感兴趣的操作。

### FACTORY METHOD(工厂方法)

- 意图

	- 定义一个用于创建对象的接口，让子类决定实例化哪一个类。
	- Factory Method 使一个类的实例化延迟到其子类。
	- 让子类决定创建的对象是什么，来达到对象的过程封装的目的。

- 别名

	- 虚构造器（Virtual Constructor）

- 动机

	- 框架使用抽象类定义和维护对象之间的关系。这些对象的创建通常也由框架负责。

- 适用性

	- 当一个类不知道它所必须创建的对象的类的时候。
	- 当一个类希望由它的子类来指定它所创建的对象的时候
	- 当类将创建对象的职责委托给多个帮助子类中的某一个，并且你希望将哪一个帮助子类是代理者这一信息局部化的时候。

- 结构

	- 

- 参与者

	- Product

		- 定义工厂方法所创建的对象的接口

	- ConcreteProduct

		- 实现Product接口

	- Creator

		- 声明工厂方法，该方法返回一个Product类型的对象。
		- Creator也可以定义一个工厂方法的缺省实现，它返回一个缺省的ConcreteProduct对象
		- 可以调用工厂方法以创建一个Product对象

	- ConcreteCreator

		- 重定义工厂方法以返回一个ConcreteProduct实例

- 协作

	- Creator依赖于它的子类来定义工厂方法，所以它返回一个适当的ConcreteProduct实例。

- 效果

	- 优缺点

		- 工厂方法不再将与特定应用有关的类绑定到你的代码中。代码仅处理Product接口；因此它可以与用户定义的任何ConcreteProduct类一起使用。
		- 工厂方法的一个潜在缺点在于客户可能仅仅为了创建一个特定的ConcreteProduct对象，就不得不创建Creator的子类。当Creator子类不必需时，客户现在必然要处理类演化的其他方面；但是当客户无论如何必须创建Creator的子类时，创建子类也是可行的。

	- 效果

		- 为子类提供挂钩（hook）

			- 用工厂方法在一个类的内部创建对象通常比直接创建对象更灵活。Factory Method给子类一个挂钩以提供对象的扩展版本。

		- 连接平行的类层次

			- 迄今为止，在我们所考虑的例子中，工厂方法并不往往只是被Creator调用，客户可以找到一些有用的工厂方法，尤其在平行类层次的情况下。

- 实现

	- 两种情况

		- Creator类是一个抽象类并且不提供它所声明的工厂方法的实现
		- Creator是一个具体的类而且为工厂方法提供一个缺省的实现，也有可能有一个定义了缺省实现的抽象类，但这不太常见。

	- 参数化工厂方法

		- 该模式的另一种情况使得工厂方法可以创建多种产品。
		- 工厂方法采用一个标识要被创建的对象种类的参数。
		- 工厂方法创建的所有对象将工厂Product接口。

	- 使用模板以避免创建子类

		- 工厂方法的另一个潜在问题时它们可能仅为了创建适当的product对象而迫使你创建Creator子类。

	- 命名约定

		- 使用命名约定是一个好习惯，它可以清楚地说明你正在使用工厂方法。

### PROTOTYPE(原型)

- 意图

	- 用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象

- 适用性

	- 当一个系统应该独立于它的产品创建、构成和表示时，要使用Prototype模式
	- 当要实例的类是在运行时刻指定时，例如通过动态装载
	- 为了避免创建一个与产品类层次平行的工厂类层次时
	- 当一个类的实例只能有几个不同状态的组合中的一重时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。

- 参与者

	- Prototype

		- 声明一个克隆自身的接口

	- ConcretePrototype

		- 实现一个克隆自身的操作

	- Cilent

		- 让一个原型克隆自身从而创建一个新的对象

- 结构

	- 

- 协作

	- 客户请求一个原型克隆自身。

- 效果

	- Prototype有许多和Abstract Factory 和Builder一样的效果：它对客户隐藏了具体的产品类，因此减少了客户知道的名字的数目。此外，这些模式使客户无需改变即可使用与特定应用相关的类。
	- 优点

		- 运行时刻增加和删除产品

			- prototype允许客户注册原型实例就可以将一个新的具体产品类并入系统。它比其他创建型模式更为灵活，因为客户可以在运行时刻建立和删除原型。

		- 改变值以指定新对象

			- 高度动态的系统允许你通过对象符合定义新的行为——例如，通过为一个对象变量指定值——并且比定义新的类。
			- 你通过实例化已有类并且将这些实例注册为客户对象的原型，就可以有效定义新类别的对象。
			- 客户可以将职责代理给原型，从而表现出新的行为。

		- 改变结构以指定新对象

			- 许多应用由部件和子部件来创建对象。
			- 为方便起见，这样的应用通常允许你实例化复杂的、用户定义的结构。比如一次又一次的重复使用一个特定的子电路。

		- 减少子类的构造

			- Factory Method 经常产生以与产品类层次平行的Creator类层次。Prototype 模式使得你克隆一个原型而不是请求一个工厂方法去产生一个新的对象。因为你根本不需要Creator类层次。
			- 适用于像C++这样不将类作为一级类对象的语言。

		- 用类动态配置

			- 一些运行时刻环境允许你动态将类装载到应用中。在像C++这样的语言中，Prototype模式是利用这种功能的关键。

	- 缺点

		- 每一个Prototype的子类都必须实现Clone操作，这可能很困难。

- 实现

	- 在C++这样的静态语言中，类不是对象，并且运行时刻只能得到很少或者得不到任何类型信息，所有Prototype特别有一些。
	- 问题

		- 使用一个原型管理器

			- 当一个系统中原型数目不固定时（也就是说，它们可以动态创建和销毁），要保持一个可用原型的注册表。客户不会自己来管理原型，但会在注册表中存储和检索原型。客户在克隆一个原型前会向注册表请求该原型。我们称这个注册表为原型管理器（prototype manager）。
			- 原型管理器是一个关联存储器（associative store），它返回一个与给定关键字相匹配的原型。它有一些操作可以用来通过关键字注册原型和解除原型。客户可以在运行时更改甚或浏览这个注册表。这使得客户无需编写代码就可以扩展并得到系统清单。

		- 实现克隆操作

			- Prototype模式最困难的部分在于正确实现Clone操作，当对象结构包含循环引用时，这尤为棘手。

		- 初始化克隆对象

			- 当一些客户对克隆对象已经相当满意时，一些客户将会希望使用它们所选择的一些值来初始化该对象的一些或是所有的内部状态。一般来首不可能在Clone操作中传递这些值，因为这些值的数目优于原型类的不同而会有所不同。一些原型可能需要多个初始化参数，另一些可能什么都不要。在Clone操作中传递参数会破坏克隆接口的统一性。

### SINGLETON(单件)

- 意图

	- 保证一个类仅有一个实例，并提供一个访问它的全局访问点。

- 动机

	- 对于一些类来说，只有一个实例是很重要的。

- 适用性

	- 当类只有一个实例而且客户可以从一个众所周知的访问点访问它时。
	- 当这个唯一实例应该是通过子类化可扩展的，并且客户应该无需更改代码就能使用一个扩展实例时。

- 结构

	- 

- 参与者

	- Singleton

		- 定义一个Instance操作，允许客户访问它的唯一实例。Instance是一个类操作
		- 可能负责创建它自己的唯一实例。

- 协作

	- 客户只能通过Singleton的Instance操作访问一个Singleton的实例。

- 效果

	- 对唯一实例的受控访问

		- 因为Singleton类封装它的唯一实例，所以它可以改严格的控制客户怎样以及何时访问它

	- 缩小名空间

		- Singleton 模式是对全局变量的一个改进。它避免了那些存储唯一实例的全局变量污染名空间。

	- 允许对操作和表示的精化

		- Singleton类可以有子类，而且用这个扩展类的实例来配置一个应用是很容易的。你可以用你需要的类的实例在运行时刻配置应用。

	- 允许可变数目的实例

		- 这个模式使得你易于改变你的相仿，并允许Singleton类的多个实例。此外，你可以用相同的方法控制应用所使用的实例的数目。只有允许访问Singleton实例的操作需要改变。

	- 比类操作更灵活

		- 另一种封装单件功能的方式是使用类操作

- 实现

	- 保证一个唯一的实例

		- Singleton模式使得这个唯一实例是类的一般实例，但该类被写成只有一个实例能被创建。做到这一点的一个常用方法时将创建这个实例的操作隐藏在一个类操作后面。由它保证只有一个实例被创建。这个操作可以访问保存唯一实例的变量，而且它可以保证这个变量在返回值之前用这个唯一实例初始化。这种方法保证了单件在它的首次使用前被创建和使用。

	- 创建Singleton类的子类

		- 主要问题与其说是定义子类不如说是建立它的唯一实例，这样客户就可以使用它。
		- 事实上，指向单件实例的变量必须用子类的实例进行初始化。最简单的技术是在Singleton的Instance操作中决定你想使用的是哪一个单件。
		- 另一个选择是Singleton的子类方法是将Instance的实现从父类中分离出来并将它放入子类。

- java实现方式

	- 饿汉式（线程安全，调效率高不能延时加载）

		- public class ImageLoader{ 
     private static ImageLoader instance = new ImageLoader; 
     private ImageLoader(){} 
     public static ImageLoader getInstance(){  
          return instance;  
      } 
}

	- 懒汉式（线程安全，调用效率不高，但能延时加载）如果不加同步方法，则线程不安全，加同步方法，则效率低下。

		- public class SingletonDemo2 {
     
    //类初始化时，不初始化这个对象(延时加载，真正用的时候再创建)
    private static SingletonDemo2 instance;
     
    //构造器私有化
    private SingletonDemo2(){}
     
    //方法同步，调用效率低
    public static synchronized SingletonDemo2 getInstance(){
        if(instance==null){
            instance=new SingletonDemo2();
        }
        return instance;
    }
}

	- Double CheckLock 实现单例
双重锁判断机制（由于JVM底层模型原因，偶尔出现问题，不推荐使用）（已被淘汰）

		- public class SingletonDemo5 {
        private volatile static SingletonDemo5 SingletonDemo5;

        private SingletonDemo5() {
        }

        public static SingletonDemo5 newInstance() {
            if (SingletonDemo5 == null) {
                synchronized (SingletonDemo5.class) {
                    if (SingletonDemo5 == null) {
                        SingletonDemo5 = new SingletonDemo5();
                    }
                }
            }
            return SingletonDemo5;
        }
    }

	- 静态内部类实现模式（线程安全，调用效率高，可以延时加载）

		- public class SingletonDemo3 {

    private static class SingletonClassInstance{
        private static final SingletonDemo3 instance=new SingletonDemo3();
    }

    private SingletonDemo3(){}

    public static SingletonDemo3 getInstance(){
        return SingletonClassInstance.instance;
    }

}

	- 枚举类（线程安全，调效率高，不能延时加载，可以天然的防止反射和反序列化调用）

		- public enum SingletonDemo4 {

    //枚举元素本身就是单例
    INSTANCE;

    //添加自己需要的操作
    public void singletonOperation(){
    }
}

## 结构型模式

### ADAPTER(适配器)

- 意图

	- 将一个类的接口转换成客户希望的另一个接口。
	- Adapter模式使得原本优于接口不兼容而不能一起工作的类可以一起工作。

- 别名

	- 包装器Wrapper

- 动机

	- 有时，为复用而设计的工具箱不能够被复用的原因仅仅是因为它的接口与专业应用领域所需要的接口不匹配。

- 适用性

	- 你想使用一个已经存在的类，而它的接口不符合你的需求
	- 你想创建一个可以复用的类，该类可以与其他不相关或不可预见的类（即那些接口可能不一定兼容的类）协同工作。
	- （仅适用于对象Adapter）你想使用一些已经存在的子类，但是不可能对每一个都进行子类化以匹配它们的接口。对象适配器可以适配它的父类接口。

- 结构

	- 适用于多重继承的结构图

		- 

	- 适用于组合的结构图

		- 

- 参与者

	- Target

		- 定义Client使用的与特定领域相关的接口

	- Client

		- 与符合Target接口的对象协同

	- Adaptee

		- 定义一个已经存在的接口，这个接口需要适配

	- Adapter

		- 对Adaptee的接口与Target接口进行适配

- 协作

	- Client在Adapter实例上调用一些操作。接着适配器调用Adaptee的操作实现这个请求。

- 效果

	- 类适配器和对象适配器有不同的权衡。
	- 类适配器

		- 用一个具体的Adapter类对Adaptee和Target进行匹配。结果是当我们想要匹配一个类以及它的子类时，类Adapet不能胜任工作。
		- 使得Adapter可以重定义Adaptee的部分行为，因为Adapter是Adaptee的一个子类。
		- 仅仅引入了一个对象，并不需要额外的指针以间接得到Adaptee。

	- 对象适配器则

		- 允许一个Adapter与多个Adaptee——即Adaptee本身以及它的所有子类（如果有子类的话）同时工作。Adapter也可以一次给所有的adaptee添加功能
		- 使得重定义Adaptee的行为比较困难。这就需要生成Adaptee的子类并且使得Adapter引用这个子类而不是引用Adaptee本身。

	- 使用Adapter模式时需要考虑的一些因素有

		- Adapter的匹配程度

			- 对Adaptee的接口与Target的接口进行配备的工作量各个Adapter可能不一样。
			- Adapter的工作量取决于Target接口与Adaptee接口的相似程度。

		- 可插入的Adapter

			- 当其他的类使用一个类时，如果所需的假定条件越少，这个类就更具复用性。
			- 如果将接口匹配构建为一个类，就不需要假定对其它的类可见的是一个相同的接口。

		- 使用双向适配器提供透明操作

			- 在两个不同的客户需要用不同的方式查看同一个对象时，双向适配器尤其有用。

- 实现

	- 使用C++实现适配器类

		- Adapter类应该采用公共方式继承Target类，并且用私有方式继承Adaptee类。

	- 可插入的适配器

		- 为Adaptee找到一个“窄”接口，即可用于适配的最小操作集。因为包含较少操作的窄接口相对宝海较多草垛的宽接口比较容易进行匹配。
		- 实现方式

			- 使用抽象操作
			- 使用代理对象
			- 参数化的适配器

- 相关模式

	- 模式Bridge的结果与对象适配器类似，但是Bridge模式的出发点不同

		- Bridge目的是将接口部分与实现部分分离，从而对它们可以较为容易也相对独立的加以改变。
		- Adapter则意味着改变一个已有对象的接口。

	- Decorator模式增强了其他对象的功能而同时又不改变它的接口。

		- 因此decorator对应用程序的透明性比适配器要好。
		- 结果是decorator支持递归组合，而纯粹使用适配器是不可能实现这一点的。

	- 模式Proxy在不改变它的接口的条件下，为另一个对象定义了一个代理。

### BRIDGE(桥接)

- 意图

	- 将抽象部分与它的实现部分分离，使它们都可以独立地变化。

- 别名

	- Handle/Body

- 动机

	- 当一个抽象可能有多个实现时，通常用继承来协调它们。
	- 抽象类定义对抽象的接口，而具体的子类则用不同方式加以实现。但是此方法有时不够灵活。继承机制将抽象部分与它的实现部分固定在一起，使得难以对抽象部分和实现部分独立进行修改，扩充和重用。

- 适用性

	- 你不希望在抽象和它的实现部分之间有一个固定的绑定关系。
	- 类的抽象以及它的实现都可以通过生成子类的方法加以扩充。这时Bridge模式使你可以对不同的抽象接口和实现部分进行组合，并分别对它们进行扩充。
	- 对一个抽象的实现部分的修改应对客户不产生影响，即客户的代码不必重新编译。
	- （C++）你想对客户完全隐藏抽象部分。在C++中类的表示在类接口中是可见的。
	- 有许多类要生成。这样一种种类层次结构说明你必须将对象分解成两个部分。Rumbaugh称这种类层次为“嵌套的普化”（nested generalizations）
	- 你想在多个对象间共享实现（可能使用引用计数），但同时要求客户并不知道这一点。

- 结构

	- 

- 参与者

	- Abstraction

		- 定义抽象类的接口
		- 维护一个指向Implementor类型对象的指针

	- RefinedAbstraction

		- 扩充由Abstraction定义的接口

	- Implementor

		- 定义实现类的接口，该接口不一定要与Abstraction的接口完全一致
		- 事实上这两个接口可以完全不同。一般来讲，Implemnetor接口仅提供基本操作，而Abstraction则定义了基于这些基本操作的较高层次的操作。

	- ConcreteImplementor

		- 实现Implementor接口并定义它的具体实现

- 协作

	- Abstraction将Client的请求转发给它的Implemnentor对象

- 效果

	- 优点

		- 分离接口及其实现部分

			- 一个实现未必不变地绑定在一个接口上。抽象类的实现可以在运行时刻进行配置，一个对象甚至可以在运行时刻改变它的实现。
			- 将Abstraction与Implementor分离有助于降低对实现部分编译时刻的依赖性，当改变实现类时，并不需要重新编译Abstraction类和它的客户程序。

				- 为了保证一个类库的不同版本之间的二进制兼容性，一定要有这个性质。

			- 接口和分离有助于分层，从而产生更好的结构化系统，系统的高层部分仅需知道Abstraction和Implementor即可

		- 提高可扩充性

			- 你可以独立地对Abstraction和Implementor层次结构进行扩充。

		- 实现细节对客户透明

			- 你可以对客户隐藏实现细节，如共享Implementor对象以及相应的引用计数机制。

- 实现

	- 仅有一个Implementor

		- 在仅有一个实现的时候，没有必要创建一个对象的Implementor类。这个Bridge模式的退化情况
		- 在Abstraction与Implemntor之间有一种一对一的关系。
		- 尽管如此，当你希望改变一个类的实现不会影响已有的客户程序时，模式的分离机制还是非常有用的——不必重新编译它们，仅需重新连接即可。

	- 创建正确的Implementor对象

		- 当存在多个Implementor类的时候，可以在构造器中对其中的一个类进行实例化，它可以通过传递给构造器的参数确定实例化哪个类。
		- 另一种方法时首先选择一个缺省的实现，然后根据需要改变这个实现。
		- 也可以代理给另一个对象，由它一次决定。

	- 共享Implemnttor对象
	- 采用多重继承机制

		- 在C++中可以使用多重继承机制将抽象接口和它的实现部分结合起来。

- 相关模式

	- Abstract Factory模式可以用来创建和配置一个特定的Bridge模式
	- Adapter模式用来帮助无关的类协同工作，它通常在系统设计完成后才会被使用。然而，Bridge模式则是在系统开始时就被使用，它使得抽象接口和实现部分可以独立进行改变。

### COMPOSITE(组合)

- 意图

	- 将对象组合成树形结构以表示“部分-整体”的层次结构。Composite使得用户对单个对象和组合对象的使用具有一致性。

- 动机

	- 描述了如何使用递归组合，使得用户不必对这些类进行区别

- 适用性

	- 你想表示对象的部分-整体结构
	- 你希望用户忽略组合对象和单个对象的不同，用户将统一地使用组合结构中的所有对象。

- 结构

	- 

- 参与者

	- Component（Graphic）

		- 为组合中的对象声明接口
		- 在适当的情况下，实现所有类共有接口的缺省行为
		- 声明一个接口用于访问和管理Component组件
		- （可选）在递归结构中定义一个接口，用于访问一个父部件，并在合适的情况下实现它。

	- Leaf

		- 在组合中表示叶节点对象，叶节点没有子节点
		- 在组合中定义图元对象的行为

	- Composite

		- 定义有子部件的那些部件的行为。
		- 存储子部件
		- 在Component接口中实现与子部件有关的操作

	- Client

		- 通过Component接口操纵组合部件的对象

- 协作

	- 用户使用Component类接口与组合结构中的对象进行交互。如果接收者是一个叶节点，则直接处理请求。如果接收者是Composite，它通常将请求发送给它的子部件，在转发请求之前与/或之后可能执行一些辅助操作

- 效果

	- Composite模式

		- 定义了包含基本对象和组合对象的类层次结构

			- 基本对象可以被组合成更复杂的组合对象，而这个组合对象又可以被组合，这样不断的递归下去。客户代码中，任何用到基本对象的地方都可以使用组合对象

		- 简化客户代码

			- 客户可以一致地使用组合结构和单个对象。通常用户不知道（也不关心）处理的是一个叶节点还是一个组合组件。这就简化了客户代码，因为在定义组合的那些类中不需要写一些充斥着选择语句的函数。

		- 使得更容易增加新类型的组件

			- 新定义的Compositte或Leaf子类自动地与已有的结构和客户代码一起工作，客户程序不需要因新的Component类而改变

		- 使你的设计变得更加一般化

			- 容易增加的新组件也会产生一些问题，那就是很难限制组合中的组件。有时你希望一个组合只能有特定的组件。
			- 使用Composite时，你不能依赖系统施加这些约束，而必须在运行时刻进行检查。

- 实现

	- 显式的父部件引用

		- 保持从子部件到父部件的引用能简化组合结构的遍历和管理。父部件引用可以简化结构的上移和组件的删除，同时父部件引用也支持Chain of Responsibilty模式
		- 通常在Component类中定义父部件引用。leaf和Composite类可以继承这个引用以及管理这个引用的那些操作。

	- 共享组件

		- 共享组件是很有用的，比如它可以减少对存贮的需求。但是当一个组件只有一个父部件时，很难共享组件。

	- 最大化Component接口

		- Componsite模式的目的一致是使得用户不知道他们正在使用的Leaf和Componsite类。为了达到这一目的，Composite类应为Leaf和Composite类尽可能多定义一些公共操作。Composite类通常为这些操作提供缺省的实现，而Leaf和Composite子类可以对它们进行重定义。

	- 声明管理子部件的操作
	- Component是否应该实现一个Component列表
	- 子部件排序
	- 使用高速缓存存贮改善性功能

		- 如果你需要对组合进行频繁的遍历或查找，Composite类可以缓冲存储对它的子节点进行遍历或查找的相关信息。

	- 应该由谁删除Component

		- 在没有垃圾回收机制的语言中，当一个Composite被销毁时，通常最账册由Composite负责删除子节点。但有一种情况除外，即Leaf对象不会改变，因此可以被共享。

	- 存贮组件最好用哪一种数据结构

		- Composite可使用多种数据结构存贮它们的子节点，包括连接列表、书、数组和hash表。数据结构取决于效率。事实上，使用通用数据结构没有必要。有时对每个子节点，Composite都有一个变量与之对应，这就要求Composite的每个子类都要实现自己的管理接口。

- 相关模式

	- 通常部件-父部件连接用于Responsibility of Chain模式
	- Decorator模式经常与Composite模式一起使用。当装饰和组合一起使用时，它们通常有一个公用的父类。因此装饰必须支持具有Add、Remove和GetChild操作的Component接口
	- Flyweight让你共享组件，但不再能引用他们的父部件
	- Itertor可用来遍历Composite
	- Vistior将本来分布在Composite和Leaaf类中的操作和行为局部化。

### DECORATOR(装饰)

- 意图

	- 动态地给一个对象添加一些额外的职责。就增加功能来说，Decorator模式相比生成子类更为灵活。

- 别名

	- 包装器Wrapper

- 动机

	- 有时我们希望给某个对象而不是整个类添加一些功能

- 适用性

	- 在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责
	- 处理那些可以撤销的职责
	- 当不能采用生成子类的方式进行扩充时。

		- 一种情况是，可能有大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长。
		- 另一种情况是因为子类被隐藏，或类定义不能用于生成子类。

- 结构

	- 

- 参与者

	- Component

		- 定义一个对象接口，可以给这些对象动态地添加职责

	- ConcreteComponent

		- 定义一个对象，可以给这个对象添加一些职责

	- Decorator

		- 维持一个指向Component对象的指针，并定义一个与Componment接口一致的接口。

	- ConcreteDecorator

		- 向组件添加职责

- 协作

	- Decorator将请求转发給它的Component对象，并有可能在转发请求前后执行一些附加的动作。

- 效果

	- 优点

		- 比静态继承更灵活

			- 与对象的静态继承（多重继承）相比，Decorator模式提供了更加灵活的向对象添加职责的方式。可以用添加和分离的方法，用装饰在运行时刻增加和删除职责。

		- 避免在层次结构高层的类有太多的特征

			- Decorator模式提供了一个“即用即付”的方式来添加职责。它并不试图在一个复杂的可定制的类中支持所有可见性的特征，相反，你可以定义一个简单的类，并且用Decorator类给它逐渐地添加功能。

	- 缺点

		- Decoratror与它的Component不一样

			- Decorator是一个透明的包装。如果我们从对象标识的观点出发，一个被装饰了的组件与这个组件是有区别的，因此，使用装饰时不应该依赖对象标识。

		- 有许多小对象

			- 采用Decorator模式进行系统设计往往会产生许多看上去类似的小对象，这些对象仅仅在他们相互连接的方式上有所不同，而不是它们的类或是它们的属性值有所不同。
			- 尽管对于那些了解这些系统的人来说，很容易对它们进行定制，但是很难学习这些系统，排错也很困难。

- 实现

	- 接口的一致性

		- 装饰对象的接口必须与它所装饰的Component的接口是一致的，因此，所有的ConcreteDecoratror类必须有一个公共的父类。

	- 省略抽象的Decorator类

		- 你常常需要处理现存的类层次结构而不是设计一个新系统，这时你可以把Decorator向Componment转发请求的职责合并到ComcreteDecoratro中。

	- 保持Component类的简单性

		- 为了保证接口的一致性，组件和装饰必须有一个公共的Component父类。因此保持这个类的简单性是很重要的
		- 即，它应集中于定义接口而不是存储数据。对数据表示的定义应延迟到子类中，否则Component类会变得过于复杂和胖的，因而难以大量使用。

	- 改变对象外壳与改变对象内核

		- 我们可以将Decorator看一个对象的外壳，它可以改变这个对象的行为。另外一种方法是改变对象的内核。如Strategy模式
		- 当Component类原本就很庞大时，使用Decorator模式代价太高，Strategy模式相对更好一些。

- 相关模式

	- Adapter模式

		- Decorator模式不同于Adapter模式，因为装饰仅改变对象的职责而不改变它的接口，而是适配器给对象一个全新的接口。

	- Composite模式

		- 可以将装饰视为一个退化的、仅有一个组件的组合。然而，装饰仅给对象添加一些额外的职责——它的目的不在于对象聚集。

	- Strategy模式

		- 用一个装饰你可以改变对象的外表，而Strategy是你可以改变对象的内核。这是改变对象的两种途径。

- 应用

	- java中的I/O是装饰者模式的体现

### FACADE(外观)

- 意图

	- 为子系统中的一组接口提供一个一致的界面，Faacade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。

- 动机

	- 将一个系统划分成为若干个子系统有利于降低系统的复杂性。
	- 一个常见的设计目标是使子系统间的通信和相互依赖关系达到最小。
	- 达到该目标的途径之一就是引入一个外观（facade）对象，它为子系统中较一般的设施提供了一个单一而简单的界面。

- 适用性

	- 当你要为一个复杂子系统提供一个简单接口时，子系统往往因为不断演化而变得越来越复杂。
	- 大多数模式使用时都会产生更多更小的类。这使得子系统更具重用性，也更容易对子系统进行定制，但这也给那些不需要定制子系统的用户带来一些使用上的困难。
	- 客户程序与抽象类的实现部分之间存在着很大的依赖性。引入facade将这个子系统与客户以及其他的子系统分离，可以提高子系统的独立性和可移植性。
	- 当你需要构建一个层次结构的子系统时，使用facade模式定义子系统中每层的入口点。如果子系统之间是相互依赖的，你可以通过让它们仅通过facade进行通讯，从而简化了它们之间的依赖关系。

- 结构

	- 

- 参与者

	- Facade

		- 知道哪些子系统类负责处理请求
		- 将客户晒请求代理而给适当的子系统对象

	- SubSystem class

		- 实现子系统的功能
		- 处理由Facade对象指派的任务
		- 没有Facade的相关信息，即没有指向Facade的指针

- 协作

	- 客户程序通过发送请求給Facade的方式与子系统通讯，Facade将这些消息转发给适当的子系统对象。尽管是子系统中的有关对象在做实际工作，但Facade模式本身也必须将它的接口转换成子系统的接口。
	- 使用Facade的客户程序不需要直接访问子系统对象。

- 效果

	- 它对客户屏蔽子系统组件，因而减少了客户处理的对象的数目并使得子系统使用起来更加方便。
	- 它实现了子系统与客户之间的松耦合关系，而子系统内部的功能组件往往是紧耦合的。松耦合关系使得子系统的组件变化不会影响它的客户。

		- Facade模式有助于帮助建立层次结构系统，也有助于对象之间的依赖关系分层。Facade模式可以消除复杂的循环依赖关系，这一点在客户程序和子系统是分别实现的时候尤为重要。

	- 如果应用需要，它并不限制它们使用子系统类，因此你可以在系统易用性和通用性之间加以选择。

- 实现

	- 降低客户-子系统之间的耦合度

		- 用抽象类实现Facade而它的具体子类对应于不同的子系统实现，这可以进一步降低客户与子系统的耦合度

	- 公共子系统类与私有子系统类

		- 一个子系统与一个类的相似之处是，它们都有接口并且它们都封装了一些东西——类封装了状态和操作，而子系统封装了一些类。
		- 考虑一个类的公共和私有接口是有益的，我们也可以考虑子系统的公共和私有接口。
		- 子系统的公共接口包含所有的客户程序可以访问的类，私有接口仅用于对子系统进行扩充

- 相关模式

	- Abstract Factory模式可以与Facade模式一起使用以提供一个接口，这一接口可用来以一种子系统独立的方式创建子系统对象。Abstract Factory也可以带代替Facade模式隐藏那些与平台相关的类。
	- Mediator模式与Facade模式的相似之处是，它抽象了一些已有的类的功能。然而，mediator的目的是对同事之间的任意通讯进行抽象，通常集中不属于任何单个对象的功能。

		- Mediator的同事对象知道中介者并与它进行通信，而不是之间与其他同类对象通信。
		- 相对而言，Facade模式仅对子对象的接口进行抽象，从而使它们更容易使用。它并不定义新功能，子系统也不知的facade的存在。

	- 通常来讲，仅需要一个Facade对象，因此Facade对象通常属于Singleton模式

### FLYWEIGHT(享元)

- 意图

	- 运用共享技术有效地支持大量细粒度的对象

- 动机

	- 有些应用程序得益于在其整个设计过程中采用对象技术，但简单化的实现代价极大。

- 适用性

	- 一个应用程序使用了大量的对象
	- 完全由于使用大量的对象，造成很大的存储开销
	- 对象的大多数状态都可变为外部状态
	- 如果删除对象的外部状态，那么可以用相对较少的共享对象取代很多组对象。
	- 应用程序不依赖于对象标识。由于Flyweight对象可以被共享，对于概念上明显有别的对象，标识测试将返回真值。

- 结构

	- 

- 参与者

	- Flyweight

		- 描述一个接口，通过这个接口flyweight可以接受并作用与外部状态

	- ConcreteFlyweight

		- 实现Flyweight交界口，并为内部状态（如果有的话）增加存储空间。
		- ConcreteFlyWeight对象必须是可共享的。它所存储的状态必须是内部的；即，它必须独立于ConcreteFlyweight对象的场景。

	- UnsharedConcretFlyweight

		- 并非所有的Flyweigth子类都需要被共享。Flyweight接口使共享成为可能，但它并不强制共享。
		- 在Flyweight对象结构的某些层次，UnsharedConcreteFlyweight对象通常将ConcreteFlyweight对象作为子节点

	- FlyweightFactory

		- 创建并管理flyweight对象
		- 确保合理地共享flyweight。当用于请求一个flyweight时，FlyweightFactory对象提供一个已创建的实例或者创建一个（如果不存在的话）。

	- Client

		- 维持一个对flyweight的引用
		- 计算或存储一个（多个）flyweight的外部状态

- 协作

	- flyweigh执行时所需的状态必定是内部或外部的。

		- 内部状态存储于ConcreteFlyWeight对象之中
		- 而外部对象则由Client对象存储或计算。当用户调用flyweight对象的操作时，将该状态传递给它

	- 用户不应直接对ConcreteFlyweigth类进行实例化，而只能从FlyweightFactory对象得到ConcreteFlyweight对象，这可以保证对它们适当地进行共享。

- 效果

	- 使用Flyweight模式时，传输、查找和/或计算外部状态都会产生运行时的开销，尤其当flyweight原先被存储为内部状态时。然而，空间上的节省抵消了这些开销。共享的Flyweight越多，空间节省也就越大
	- 存储节约由以下几个元素决定

		- 因为共享，实例总数减少的数目
		- 对象内部状态的平均数目
		- 外部状态时计算的还是存储的

- 实现

	- 删除外部状态

		- 该模式的可用性在很大程度上取决于是否容易识别外部状态并将它从共享对象中删除。
		- 如果不同种类的外部状态和共享前对象的数目相同的话，删除外部状态不会降低存储消耗。
		- 理想的状况是，外部状态可以由一个单独的对象结构计算得到，且该结构的存储要求非常小。

	- 管理共享对象

		- 因为对象是共享的，用户不能直接对它进行实例化，因此FlyweightFactory可以帮助用户查找某个特定的Flyweight对象。FlyweightFactory对象经常使用关联存储帮助用户查找感性与的Flyweight对象。
		- 共享还意味着某种形式的引用计数和垃圾回收，这样当一个Flyweight不再使用时，可以回收它的存储空间。

### PROXY(代理)

- 意图

	- 为另一个对象提供一个替身占位符以控制这个对象的访问。

- 别名

	- Surrogate

- 动机

	- 对一个对象进行访问控制的一个原因是为了只有在我们确实需要这个对象时才对它进行创建和初始化。

		- 类似于Html占位

- 适用性

	- 在需要用比较通用和复杂的对象指针代替简单指针的时候，使用Proxy模式。

		- 远程代理（Remote Proxy）为一个对象在不同的地址空间提供局部代表。NEXTSTEP使用NXProxy类实现了这一目的。
		- 虚代理（Virtual Proxy）根据需要创建开销很大的对象。
		- 保护代理（Protection Proxy）控制对原始对象的访问。保护代理用于对象应该有不同的访问权限的时候。
		- 只能指引（Smart Reference）取代了简单指针，它在访问对象时执行一些附加操作。

			- 对指向实际对象的引用计数，这样当该对象没有引用时，可以自动释放它
			- 当第一次引用一个持久对象时，将它装入内存。
			- 在访问一个实际对象前，检查是否已经锁定了它，以确保其他对象不能改变它。

- 结构

	- 

- 参与者

	- Proxy（ImageProxy）

		- 保存以引用使得代理可以访问实体。
		- 提供一个与Subject的接口相同的接口，这样代理就可以用来替代实体。
		- 控制对实体的存取，并可能负责创建和删除它
		- 其他功能依赖于代理的类型

			- Remote Proxy 负责对请求及其参数进行编码，并向不同地址空间中的实体发送已编码的请求
			- Virtual Proxy 可以缓存实体的附加信息，以便延迟对它的访问。
			- Protection Proxy 检查调用者是否具有实现一个请求所需的访问权限。

	- Subject

		- 定义RealSubject和Proxy的公用接口，这样就在任何使用RealSubject的地方都可以使用Proxy。

	- RealSubject

		- 定义Proxy所代表的实体

- 协作

	- 代理根据其种类，在适当的时候向RealSubject转发请求

- 效果

	- Proxy模式在访问对象时引入了一定程度的间接性。根据代理的类型，附加的简介性有多重用途

		- Remote Proxy可以隐藏一个对象存在于不同地址空间的事实
		- Virtual Proxy 可以进行最优化，例如根据要求创建对象。
		- Protection Proxies和Smart Reference都允许在访问一个对象时有一些附加的内务处理（Housekeeping task）。

	- Proxy模式还可以对用户隐藏另一种称之为copy-on-write的优化方式，该优化与根据需要创建对象有关。

		- 拷贝一个庞大而复杂的对象是一种开销很大的操作，如果这个拷贝根本没有被修改，那么这些开销就没有必要。
		- 用代理延迟这一拷贝过程，我们可以保证只有当这个对象被修改的时候对它进行拷贝。
		- 在实现Copy-on-write时必须对实体进行引用计数。拷贝代理仅会增加引用计数。只有当用户请求一个修改该实体的操作时，代理才会真正的拷贝它。这种情况下，代理还必须减少实体的引用计数。当引用的数目为零时，这个实体将被删除。
		- Copy-on-Write可以大幅度的降低拷贝庞大实体时的开销。

- 相关模式

	- Adapter

		- 适配器Adapter为它所适配的对象提供了一个不同的接口。
		- 相反，代理提供了它的实体相同的接口。然而，用于访问保护的代理可能会拒绝执行实体会执行的操作，因此，它的接口可能只是一个实体接口的子集。

	- Decorator

		- 尽管decorator的实现部分与代理相似，但decorator的目的不一样。Decorator为对象添加一个或多个功能，而代理则对对象的访问。

### 综合对比

- Adapter与Bridge

	- 相同

		- 它们都给另一个对象提供了而一定程度上的间接性，因而有利于系统的灵活性。它们都涉及到从自身以外的一个接口向这个对象转发请求。

	- 不同

		- Adapter模式主要是为了解决两个已有接口之间不匹配的问题。它不考虑这些接口是怎样实现的，也不考虑它们可能会如何演化，

			- 这种方式不需要对两个独立设计的类中的任一个进行重新设计，就能够使它们协同工作。

		- Bridge模式则对抽象接口与它的（可能是多个）实现部分进行桥接。虽然这一模式允许你修改实现它的类，它仍然为用户提供一个稳定的接口。Bridge模式也会在系统演化时适应新的实现

	- Adapter和Bridge模式通常被用于软件生命周期的不同阶段

		- Adapter模式在类已经设计好后实施
		- Bridge模式在设计类之前实施

- Composite、Decorator与Proxy

	- 相同

		- Composite模式和Decorator模式具有相同的结构图，这说明它们都是基于递归组合来组织可变对象的。
		- Decorator与Proxy都描述了怎样为对象提供一定程度上的间接引用，proxy和decorator对象的实现部分都保留了指向另一个对象的指针，它们向这个对象发送请求。

	- 不同

		- Decorator 旨在是你能够不需要生成子类即给对象添加职责。这就避免了静态实现所有功能组合，从而导致子类急剧增加。
		- Composite则有不同的目的，它旨在构造类，使多个相关的对象能够以统一的方式处理，而多重对象可以被当做一个对象来处理。它重点不在于修饰而在于表示。
		- 像Decorator模式一样，Proxy模式构造一个对象并为用户提供一个一致的接口。但与Decorator模式不同的是，Proxy模式不能动态地添加或分离性质，它也不是为递归组合而设计的。它的目的是，当直接访问一个实体不方便或不符合需要时，为这个实体提供一个代替者。

	- Composite和Decorator模式通常协同使用。

## 对象行为型模式

### 空对象

- 在许多设计模式中，可以看到空对象的使用，甚至在某些时候，空对象也被看作是一种设计模式。

### CHAIN OF RESPONSIBILITY(职责链)

- 意图

	- 使多个对象都有机会处理请求，从而避免请求发送者和接收者之间的耦合关系。
	- 将这些对象连成一条链，并沿用这条链传递该请求，直到有一个对象处理它为止。

- 动机

	- 给多个对象处理一个请求的机会，从而解耦发送者和接受者。该请求沿对象链传递至其中一个对象处理它

- 适用性

	- 有多个的对象可以处理一个请求，哪个对象处理该请求运行时刻自动确定
	- 你想在不明确指定接收者的情况下，向多个对象中的一个提交一个请求
	- 可处理一个请求的对象集合应被动态指定

- 结构

	- 

- 参与者

	- Handler

		- 定义一个处理请求的接口
		- （可选）实现后继链

	- ConcreteHandler

		- 处理它所负责的请求
		- 可访问它的后继者
		- 如果可处理该请求，就处理之；否则将该请求转发给它的后继者

	- Client

		- 向链上的具体处理者（ConcreteHandler）对象提交请求。

- 协作

	- 当客户提交一个请求时，请求沿链传递直至有一个ConcreteHandler对象处理它。

- 效果

	- 优点

		- 降低耦合度

			- 该模式使得一个对象无需知道是其他哪一个对象处理其请求。对象仅需知道该请求会被“正确”地处理。接收者和发送者都没有对方的明确信息，且链中的对象不需要知道链中的结构。

		- 增强了给对象指派职责的灵活性

			- 当在对象中分派职责时，职责链给你更多的灵活性。你可以通过在运行时刻对该链进行动态的增加或修改来增加或处理一个请求那些职责。你可以将这种机制与静态的特例化处理对象继承机制结合起来使用。

	- 缺点

		- 不保证被接受

			- 既然一个请求没有明确的接收者，那么就不能保证它一定会被处理——该请求可能一致到链的末端都得不到处理。一个请求也可能因该链没有被正确配置而得不到处理。

- 实现

	- 实现后继者链

		- 定义新的链接（通常在Handler中定义，但也可由ConcreteHandlers 来定义）
		- 使用已有的链接

	- 连接后继者

		- 如果没有已有的引用可定义一个链，那么你必须自己引入它们。

	- 表示请求

		- 可以有不同的方法表示请求

			- 最简单的形式，请求是一个硬编码的（hard-coded）操作调用。这种方式方便而且安全，但你只能转发Handler类定义的固定的一组请求。
			- 使用一个处理函数，这个函数以一个请求码为参数。这种方式支持请求数目不限。唯一的要求是发送方和接受方在请求如何编码问题上达成一致。

				- 这种方法更为灵活，但它需要用条件语句来区分请求代码以分派请求。另外，无法用类型安全的方法来传递请求参数，因此它们必须被手工打包和解包。显然，相对于直接调用一个操作来说它不太安全。

### COMMAND(命令)

- 意图

	- 将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化
	- 对请求排队或记录请求日志，以及可撤销的操作

- 别名

	- 动作（Action）, 事务（Transaction）

- 动机

	- 有时必须向某对象提交请求，但并不知道关于被请求的操作或请求的接收者的任何信息。
	- 命令模式通过将请求本身变成一个对象来使工具箱对象可向未指定的应用对象提出请求。这个对象可被存储并像其他的对象一样被传递。

- 适用性

	- Command模式是回调机制的一个面向对象的替代品
	- 在不同的时刻指定、排列和执行请求。
	- 支持取消操作
	- 支持修改日志，这样当系统崩溃时，这些修改可以被重做一遍。

		- 在Command接口中添加装载操作和存储操作，可以用来保持变动的一个一致的修改日志。

	- 用构建在原语操作上的高层操作构造一个系统。

- 结构

	- 

- 参与者

	- Command

		- 声明执行操作的接口

	- ConcreteCommand

		- 将一个接收者对象绑定与一个动作
		- 调用接收者相应的操作，以实现Execute

	- Client

		- 创建一个具体命令对象并设定它的接收者

	- Invoke

		- 要求该命令执行这个请求

	- Receive

		- 知道如何实施与执行一个请求相关的操作。任何类都可能作为一个接收者。

- 协作

	- Client创建一个ConcreteCommand对象并指定它的Receiver对象
	- 某Invoker对象存储该ConcreteCommand对象
	- 该Invoker通过调用Command对象的Execute操作来提交一个请求。若该命令是可撤销的，ConcreteCommand就在执行Excuse操作之前存储当前状态以用于取消该命令。
	- ConcreteCommand对象对调用它的Receiver的一些操作以执行该请求。

- 效果

	- Command模式将调用操作的对象与知道如何实现的对象解耦
	- Command是头等的对象。它们可以像其他的对象一样被操纵和扩展。
	- 你可将多个命令装配成一个符合命令。一般说来，复合命令是Composite模式的一个实例。
	- 增加新的Command很容易，因为这无需改变已有的类。

- 实现

	- 一个对象命令应达到何种智能程度

		- 命令对象的能力可大可小。
		- 一个极端是它仅确定一个接收者和执行该请求的动作。
		- 另一个极端是它自己实现所有的功能，根本不需要额外的接收对象。
		- 当需要定义与已有的类无关的命令，当没有合适的接收者或当一个命令隐式地知道它的接收者时，可以使用后一极端方式。

	- 支持取消（undo）和重做（redo）

		- 如果Command提供方法逆转（reverse）它们操作的执行，就可支持取消和重做功能。为达到这个目的，ConcreteCommand类可能需要存储额外的状态信息。

			- 接收者对象，它真正执行处理该请求的各操作。
			- 接收者上执行操作的参数
			- 如果处理请求的操作会改变接收者对象中的某些值，那么这些值也必须先存储起来。接收者还必须提供一些操作，以使该命令可将接收者恢复到它先前的状态。

		- 若应用只支持一次取消操作，那么只需存储最近一次被执行的命令。而若要支持多级的取消和重做，就需要有一个已被执行的历史表列，该表列的最大长度决定了取消和重做的级数。

	- 避免取消操作过程中的错误积累

		- 在实现一个可靠、能保持原先语义的取消/重做机制时，可能会遇到滞后影响问题。
		- 优于命令重复的执行、取消执行，和重执行的过程可能会积累错误，以致一个应用的状态最终偏离初始值。这就有必要在Command中存入更多的信息以保证访问这些对象可被精确地复原成它们的初始状态。

	- 使用C++模板

		- 对（1）不能取消 （2）不需要参数的命令，我们可用C++模板实现，这样可以避免为每一种动作和接收者都创建一个Command子类。

- 相关模式

	- Composite模式可被用来实现宏命令。
	- Memento模式可用来保持某个状态，命令用这一状态来取消它的效果。

### INTERRETER(解释器)

- 意图

	- 给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。

- 动机

	- 如果遗嘱特定类型的问题发生的频率足够高，那么可能就值得将该问题的各个实例表述为一个简单语言中的句子。这样就可以构建一个解释器，该解释器通过解释这些句子来解决该问题。

- 结构

	- 

- 参与者

	- AbstractExpression(抽象表达式)

		- 声明一个抽象的解释操作，这个接口为抽象语法树中所有的节点所共享

	- TerminalExperession(终结符表达式)

		- 实现与文法中终结符相关联的解释操作
		- 一个句子中的每个终结符需要该类的一个实例

	- NonterminalExpression(非终结符表达式)

		- 对文法中的每一条规则R::= R1R2...R3都需要一个NonterminalExpression类
		- 为从R1到Rn的每个符号都维护一个AbstractExpression类型的实例变量
		- 为文法中的非终结符实现解释（Interpreter）操作。解释（Interpret）一般要递归地调用表示R1到Rn的那些对象的解释操作。

	- Context(上下文)

		- 包含解释器之外的一些全局信息。

	- Client(客户)

		- 构建（或被给定）表示该文法定义的语言中一个特定的句子的抽象语法树。该抽象语法树由NonterminalExpression和TerminalExpression的实例装配而成。
		- 调用解释操作

- 协作

	- Client构建（或被给定）一个句子，它是NonterminalExpression和TerminalExpression的实例的一个抽象语法树。然后初始化上下文并调用解释操作。
	- 每一非终结符表达式节点定义相应子表达式的解释操作。而各终结符表达式的解释操作构成了递归的基础。
	- 每一节点的解释操作用作用上下文来存储和访问解释器的状态。

- 效果

	- 优点

		- 易于改变和扩展文法

			- 因为该模式使用类来表示文法规则，你可使用继承来改变或扩展该文法。已有的表督查可被增量式地改变，而新的表达式可定义为旧表达式的变体。

		- 也易于实现文法

			- 定义抽象语法树中各个节点的类的实现大体类似。
			- 这些类易于直接编写，通常它们也可用一个编译器或语法分析程序生成器自动生成。

		- 增加了新的解释表达式的方式

			- 解释器模式使得实现新表达式“计算”变得“变得容易

	- 缺点

		- 复杂的文法难以维护

			- 解释器模式为文法中每一条规则

- 实现

	- 创建抽象语法树

		- 解释器模式并为解释如何创建一个抽象语法树。换言之，它不涉及语法分析。
		- 抽象语法树可用一个表驱动的语法分析程序来生成，也可用手写的（通常为递归下降法）语法分析程序创建，或直接由Client提供。

	- 定义解释操作

		- 并不一定要在表达式类中定义解释操作。如果经常要创建一种新的解释器，那么使用Visitor模式将解释放入一个独立的“访问者”对象更好一些。

	- 用Flyweight模式共享终结符

		- 在一些文法中，一个句子可能多次出现同一个终结符。此时最好共享那个符号的单个拷贝。

- 相关模式

	- Composite模式

		- 抽象语法树是一个复合模式的实例

	- Flyweight模式

		- 说明了如何在抽象语法树中共享终结符

	- Iterator

		- 解释器可用一个迭代器遍历该结构

	- Visitor

		- 可用来在一个类中维护抽象语法树中的各节点的行为。

### ITERATOR(迭代器)

- 意图

	- 提供一种方法顺序访问一个聚合对象中各个元素，而又不需暴露该对象的内部表示。

- 别名

	- 游标(Cursor)

- 动机

	- 一个聚合对象，应该提供一种方法来让别人可以访问它的元素，而又不需要暴露它的内部结构。

- 适用性

	- 访问一个聚合对象的内容而无需暴露它的内部表示
	- 支持对聚合对象的多种遍历
	- 为遍历不同的聚合结构提供一个同意的接口

- 结构

	- 

- 参与者

	- Iterator（迭代器）

		- 迭代器定义访问和遍历元素的接口

	- ConcreteIterator(具体迭代器)

		- 具体迭代器实现迭代器接口
		- 对该聚合遍历时跟踪当前位置

	- Aggregate(聚合)

		- 聚合定义创建相应迭代器对象的接口

	- ConcreteAggregate(具体聚合)

		- 具体聚合实现创建相应迭代器的接口，该操作返回ConcreteIterator的一个适当的实例

- 协作

	- ConcreteIterator跟踪聚合中的当前对象，并能够计算出待遍历的后继对象

- 效果

	- 它支持以不同的方式遍历一个集合

		- 复杂的聚合可用多种方式进行遍历

	- 迭代器简化了聚合的接口

		- 有了迭代器的遍历接口，聚合本身就不再需要类似的遍历接口了。这样就简化了聚合的接口。

	- 在同一个聚合上可以有多个遍历

		- 每个迭代器保持它自己的遍历状态。因此你可以同时进行多个遍历。

- 实现

	- 该控制谁迭代

		- 一个基本的问题是决定由哪一方控制该迭代，是迭代器还是使用该迭代器的客户。

			- 当由客户来控制迭代时，该迭代器称为一个外部迭代器（external iterator）
			- 当由迭代器控制跌拍时，该迭代器称为一个内部迭代器（internal iterator）

	- 谁定义遍历算法

		- 迭代器不是唯一可定义遍历算法的地方。聚合本身也可以定义遍历算法，并在遍历过程中迭代器来存储当前迭代的状态。

	- 迭代器的健壮性如何

		- 在遍历一个聚合的同时更改这个聚合是危险的。

	- 附加的迭代器操作
	- 迭代器可有特权访问
	- 用于复合对象的迭代器

		- 复合常常需要用多种方法遍历。前序，后序，中序以及广度优先遍历都是常用的。你可用不同的迭代器类来支持不同的遍历。

	- 空迭代器

		- 一个空迭代器（NullIteratro）是一个退化的迭代器，它有助于处理边界条件。

### MEDIATOR(中介者)

- 意图

	- 用一个中介对象来封装一系列的对抓了交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。

- 动机

	- 面向对象设计鼓励将行为分布到各个对象中。这种分布可能会导致对象间有许多连接。最坏的情况下,每一个对象都知道其他所有对象。

- 适用性

	- 一组对象以定义良好但是复杂的方式进行通信。产生的相互依赖关系结构混乱且难以理解。
	- 一个对象引用其他很多对象并且直接与这些对象进行通信，导致难以复用该对象。
	- 向定制一个分布在多个类中的行为，而又不想生成太多的子类。

- 结构

	- 

- 参与者

	- Mediator（中介者）

		- 中介者定义一个接口用于各同事（Colleague）对象通信。

	- ConcreteMediator(具体中介者)

		- 具体中介者通过协调各同事对象实现协作行为
		- 了解并维护它的各个同事

	- Colleague class(同事类)

		- 每一个同事类都知道它的中介者对象
		- 每一个同事对象在需与其他的同事通信的时候，与它的中介者通信。

- 协作

	- 同事向一个中介者对象发送和接收请求。中介者在各同事间适当地转发请求以实现协作行为。

- 效果

	- 优点

		- 减少了子类生成

			- Mediator将原本分布于多个对象间行为集合在一起。改变这些行为只需生成Mediator的子类即可。这样各个Colleague类可被重用。

		- 它将各Colleague解耦

			- Mediator有利于各Colleague间的松耦合。你可以独立的改变和复用各Colleague类和Mediator类

		- 它简化了对象协议

			- 用Mediator和各Colleague间一对多的交互来代替多对多的交互。一对多的关系更易于理解、维护和扩展。

		- 它对对象如何协作进行了抽象

			- 将中介作为一个独立的概念并将其封装在一个对象中，使你将注意力从对象各自本身的行为转移到它们之间的交互上来。这有助于弄清楚一个系统中的对象是如何交互的。

	- 缺点

		- 它使控制集中化

			- 中介者模式将交互的复杂性变为中介者的复杂性。因为中介者封装了协议，它可能变得比任一个Colleague都复杂。这可能使得中介者自身成为一个难以维护的庞然大物。

- 实现

	- 忽略抽象的Mediator类

		- 当各Colleague仅与一个Mediator一起工作时，没有必要定义一个Mediator类。Mediator类提供的抽象耦合已经使各Colleague可与不同的Mediator子类一起工作，反之亦然。

	- Colleague——Mediator通信

		- 当一个感兴趣的事件发生时，Colleague必须与其Mediator通信。
		- 其中一种实现时使用Observer模式，将Mediator实现为一个Observer，各Colleague作为Subject,一旦其状态改变就发送通知给Mediator.
		- 另一种方法是在Mediator中定义一个特殊的通知接口，在Colleague在通信时直接调用该接口。

- 相关模式

	- Facade与中介者的不同之处在于它是对一个对象子系统进行抽象，从而提供了一个更为方便的接口。它的协议是单向的，即Facade对象对这个子系统类提出请求，但反之则不行。相反，Mediator提供了各个Colleague对象不支持或不能支持的协作行为，而且协议是多向的。
	- Colleague可使用Observer模式与Mediator通信

### MEMENTO(备忘录)

- 意图

	- 在不破坏封装性的前提下，捕获一个对象的内部状态，并在对象之外保存这个状态。这样以后就可将对象恢复到原先保存的状态。

- 别名

	- Token

- 动机

	- 有时有必要记录一个对象的内部状态。为了允许用户取消不确定的操作或从错误中恢复过来，需要实现检查点和取消机制，而要实现这些机制，你必须事先将状态信息保存在某处，这样才能将对象恢复到它们先前的状态。
	- 但是对象通常封装了其部分或所有的状态信息，使得其状态不能被其他对象访问，也就不可能在该对象之外保存其状态。而暴露其内部状态又将违反封装原则，可能有损应用的可靠性和扩展性。
	- 一个备忘录（memento）是一个对象，它存储另一个对象在某个瞬间的内部状态，而后者称为备忘录的原发器。

- 适用性

	- 必须保存一个对象在某一时刻的（部分）状态，这样以后需要时它耐能恢复到先前的状态。
	- 如果一个用接口来让其它对象直接得到这些状态，将会暴露对象的实现细节并破坏对象的封装性。

- 结构

	- 

- 参与者

	- Memento(备忘录)

		- 备忘录存储原发器对象的内部状态。原发器根据需要决定备忘录存储原发器的哪些内部状态。
		- 防止原发器以外的其他对象访问备忘录。

	- Originator(原发器)

		- 原发器创建一个备忘录，用以记录当前时刻它的内部状态。
		- 使用备忘录恢复内部状态。

	- Caretaker(负责人)

		- 负责保存好备忘录
		- 不能对备忘录内容进行操作或检查。

- 协作

	- 管理器向原发器请求一个备忘录，保留一段时间后，将其送回给原发器。
	- 备忘录是被动的。只有创建备忘录的原发器会对它的状态进行赋值和检索。

- 效果

	- 保持封装边界

		- 使用备忘录可以避免暴露一些只应由原发器管理却又必须存储在原发器之外的信息。

	- 它简化了原发器

		- 在其他的保持封装性的设计中，Originnator负责保持客户请求过的内部状态版本。这就把所有存储管理的重任交给了Originator。让客户管理它们请求的状态将会简化Originator，并且使得客户工作结束时无需通知原发器。

	- 使用备忘录可能代价很高

		- 如果原发器在生成备忘录时必须拷贝并存储大量的信息，或者客户非常频繁地创建备忘录和恢复原发器状态，可能会导致非常大的开销。除非封装和恢复Originator状态的开销不大，否则该模式可能并不合适。

	- 定义窄接口和宽接口

		- 在一些语言中可能难以保证只有原发器可访问备忘录的状态。

	- 维护备忘录的潜在代价

		- 管理器负责删除它所维护的备忘录。然而，管理器不知道备忘录中有多少个状态。因此当存储备忘录时，一个本来很小的管理器，可能会产生大量的存储开销。

- 实现

	- 语言支持

		- 备忘录有两个接口，一个为原发器使用的宽接口，一个为其他对象所使用的窄接口。理想的实现语言应可支持两级的静态保护。

	- 存储增量式改变

		- 如果备忘录的创建及其返回（给它们的原发器）的顺序是可预测的，备忘录可以仅存储原发器内部状态的增量改变。

- 相关模式

	- Command

		- 命令可使用备忘录来为可撤销的操作维护状态

	- Iterator

		- 如前所述备忘录可用于迭代。

### OBSERVER(观察者)

- 意图

	- 定义对象间的一种一对多的依赖关系，当一个对象的状态改变时，所有依赖于它的对象都得到通知并被自动更新

- 别名

	- 依赖（Dependents）
	- 发布-订阅(Publish-Subscribe)

- 动机

	- 将系统分割成一系列相互协作的类有一个常见的副作用：需要维护相关对象间的一致性。我们不希望为了维持一致性而使各类紧密耦合，因为这样降低了它们的可重用性。
	- Observer模式描述了如何建立这种关系。这一模式中的关键对象是目标（subject）和观察者（observer）。一个目标可以有任意数目的依赖它的观察者。一旦目标的状态发生改变，所有的观察者都得到通知。
	- 作为对这个通知的响应，每个观察者都将查询目标以及使其状态与目标的状态同步。

- 适用性

	- 当一个抽象模型有两个方面，其中一方面依赖于另一方面。将这两者封装在独立的对象中以使它们可以各自独立地改变和复用。
	- 当对一个对象的改变需要同时改变其它对象，而不知道具体有多少对象有待改变。
	- 当一个对象必须通知其它对象，而它又不能假定其它对象是谁。换言之，你不希望这些对象是紧密耦合的。

- 结构

	- 

- 参与者

	- Subject(目标)

		- 目标知道它的观察者。可以有任意多个观察者观察同一个目标。
		- 提供注册和删除观察者对象的接口。

	- Observer(观察者)

		- 为那些在目标发生改变时需获得通知的对象定义一个更新接口。

	- ConcreteSubject(具体目标)

		- 将有关状态存入各ConcreteObserver对象。
		- 当它的状态发生改变时，向它的各个观察者发出通知。

	- ConcreteObserver(具体观察者)

		- 维护一个指向ConcreteSubject对象的引用
		- 存储有关状态，这些状态应与目标的状态保持一致。
		- 实现Observer的更新接口以使自身状态与目标状态保持一致。

- 协作

	- 当ConcretSubject发生任何可能导致其观察者与其本身状态不一致的改变时，它将通知它的各个观察者。
	- 在得到一个具体目标的改变通知后，ConcreteObserver对象可向目标对象查询信息。ConcreteObserver使用这些信息以使它的目标状态与目标对象的状态一致。

- 效果

	- Observer模式允许你独立的改变目标和观察者。你可以单独复用目标对象而无需同时复用其观察者，反之亦然。它也使你可以在不改动目标和其他的观察者的前提下增加观察者。
	- 优点

		- 目标和观察者间的抽象耦合

			- 一个目标所知道的仅仅是它一系列观察者，每个都符合抽象的Observer类的简单接口。
			- 目标不知道任何一个观察者属于哪一个具体的类。这样目标和观察者之间的耦合是抽象的和最小的。

		- 支持广播通信

			- 不像通常的请求，目标发送的通知不需指定它的接收者。通知被自动广播给所有已向该目标登记的有关对象。
			- 目标对象并不关心到底有多少对象对自己感兴趣；它唯一的责任就是通知它的各观察者。
			- 这给了你在任何时刻增加和删除观察者的自由。处理还是忽略一个通知取决于观察者。

	- 缺点

		- 意外的更新

			- 因为一个观察者并不知道其它观察者的存在，它可能对改变目标的最终代价一无所知。
			- 在目标上一个看似无害的操作可能会导致一系列对观察者以及依赖于这些观察者的那些对象的更新。
			- 此外，如果依赖准则的定义或维护不当，常常会引起错误的更新，这种错误通常很难捕捉。

- 实现

	- 创建目标到其观察者之间的映射

		- 一个目标对象追踪它应通知的观察者的最简单的方法时显式地在目标中保存对它们的引用。
		- 然而，当目标很多而观察者较少时，这样存储可能代价太高。
		- 一个解决方法时用时间换空间，用一个关联查找机制（例如一个hash表）来维护目标到观察者的映射。这样一个没有观察者的目标就不产生存储开销。但另一方面，这一方法增加了访问观察者的开销。

	- 观察多个目标

		- 某种情况下，一个观察者依赖于多个目标可能是有意义的。
		- 这种情况下必须扩展Update接口以使观察者知道是哪一个目标送来的通知。目标对象可以简单地将自己作为Update操作的一个参数，让观察者知道应去检查哪一个目标。

	- 谁触发更新

		- 目标和它的观察者依赖于通知机制来保持一致。此时有两个选择。
		- a） 由目标对象的状态设定操作在改变目标对象的状态后自动调用Notify。这种方法的优点是客户不需要记住要在目标对象上调用Notify,缺点是多个连续的操作会产生多次连续的更新，可能效率更低。
		- b） 让客户负责在适当的时候调用Notify。这样做的优点是客户可以在一系列的状态改变完成后再一次地触发更新，避免了不必要的中间更新。缺点是给客户增加了触发更新的责任。由于客户可能会忘记调用Notify，这种方式较易出错。

	- 对已删除目标的悬挂引用

		- 删除一个目标时应注意不要在其观察者中遗留对该目标的悬挂引用。一种避免悬挂引用的方法是，当一个目标被删除时，让它通知它的观察者将对该目标的引用复位。
		- 一般来说，不能简单地删除观察者，因为其他的对象可能会引用它们，或者也可能它们还在观察其他的目标。

	- 在发出通知前确保目标的状态自身是一致的

		- 在发出通知前确保自身一致这一点很重要，因为观察者在更新其状态的过程中需要查询目标的当前状态。

	- 避免特定于观察者的更新协议——推/拉模型

		- 观察者的实现经常需要让目标广播关于其改变的其他一些信息。目标将这些信息作为Update操作的一个参数传递出去。这些信息可能很小，也可能很大。
		- 一个极端情况是，目标向观察者发送关于改变的详细信息，而不管它们需要与否。我们称之为推模型（push model）
		- 另一个极端是拉模型（pull model）

	- 显式地指定感兴趣的改变

		- 你可以扩展目标的注册接口，让各观察者注册仅对特定事件感兴趣，以提升更新的效率。
		- 当一个事件发生时，目标仅通知那些已注册为对该时间感兴趣的观察者。

	- 封装更复杂的更新语义

		- 当目标和观察者间的依赖关系特别复杂时，可能需要一个维护这些关系的对象。我们称这样的对象为更改管理器（ChangeManager）。它的目的是尽量减少观察者反映其目标的状态变化所需的工作量。
		- ChangeManager的三个责任

			- 它将一个目标映射到它的观察者并提供一个接口来维护这个映射。这就不需要由目标来维护对其观察者的引用，反之亦然。
			- 它定义一个特定的更新策略。
			- 根据一个目标的请求，它更新所有依赖于这个目标的观察者。

	- 结合目标类和观察者类

		- 用不支持多重继承的语言书写的类库通常不但与定义Subject和Observer类，而是将它们的接口结合到一个类中。

- 相关模式

	- Mediator

		- 通过封装复杂的更新语义，ChangeManager充当目标和观察者之间的中介者。

	- Singleton

		- ChangeManager 可使用Singleton模式来保证它是唯一并且是可全局访问的。

- 应用

	- 在java的swing中，JavaBeans中都有观察者模式的体现

### STATE(状态)

- 意图

	- 允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。

- 别名

	- 状态对象（Objects for States）

- 动机

	- State模式描述了如何在每一种状态下表现出不同的行为。

- 适用性

	- 一个对象的行为取决于它的状态，并且它必须在运行适合根据状态改变它的行为。
	- 一个操作中含有庞大的多分支的条件语句，且这些分支依赖于该对象的状态。

- 结构

	- 

- 参与者

	- Context(环境）

		- 定义客户感兴趣的接口
		- 维护一个ConcreteState子类的实例，这个实例定义当前状态。

	- State(状态)

		- 定义一个接口以封装与Context的一个特定状态相关的行为。

	- ComcreteState subclasses(具体状态子类)

		- 每一子类实现一个与Context的一个状态相关的行为。

- 协作

	- Context将于状态相关的请求委托给当前的ConcreteState对象处理。
	- Context可将自身作为一个参数传递给处理该请求状态对象。这使得状态对象在必要时可访问Context。
	- Context是客户使用的主要接口。客户可用状态对象来配置一个Context，一旦一个Context配置完毕，它的客户不再需要直接与状态对象打交道。
	- Context或ConcreteState子类都可决定哪个状态是哪一个的后继者，以及是在何种条件下进行状态转换。

- 效果

	- 它将于特定状态相关的行为局部化，并且将不同状态的行为分割开来

		- State模式将所有与一个特定状态相关的行为都放入一个对象中。因为所有与状态相关的代码都存在于某一个State子类中，所以通过定义新的子类可以很容易的增加新的状态和转换。
		- 另一个方法是使用数据值定义内部状态并且让Context操作来显式地检查这些数据。但这样将会使整个Context的实现中遍布看起来很相似的条件语句或case语句。增加一个新的状态可能需要改变若干个操作，这就使得维护变得复杂了。
		- State模式避免了这个问题，但可能引入另一个问题，因为该模式将不同状态的行为分布在多个State子类中。这就增加了子类的数目，相对于单个类的实现来说不够紧凑。但是如果有许多状态时这样的分布实际上更好一些，否则需要使用巨大的条件语句。

	- 它使得状态转换显式化

		- 当一个对象仅以内部数据值来定义当前状态时，其状态表现为对一些变量的赋值，这不够明确。为不同的状态引入独立的对象使得转换变得更加明确。

	- State对象可被共享

		- 如果State对象没有实例变量——即它们表示的状态完全以它们的类型来编码——那么各Context对象可以共享一个State对象。当状态以这种方式被共享时，它们必然是没有内部状态，只有行为的轻量级对象。

- 实现

	- 谁定义状态转换

		- State模式不指定哪一个参与者定义状态转换准则。如果该准则是固定的，那么它们可在Context中完全实现。
		- 然而若让State子类自身指定它们的后继状态以及何时进行转换，通常更灵活更合适。这需要Context增加一个接口，让State对象显式地设定Context的当前状态。
		- 用这种方法分散转换逻辑可以很容易地定义新的State子类来修改和扩展该逻辑。这样做的一个缺点是，一个State子类至少拥有一个其他子类的信息，这就在各子类之间产生了实现依赖。

	- 基于表的另一种方法

		- 使用表将输入映射到状态转换。对于每一个状态，一张表将每一可能的输入映射到一个后继映射。实际上，这种方法将条件代码（和State模式下的虚函数）映射为一个查找表。
		- 表的好处是它们的规则性：你可以通过更改数据而不是更改程序代码来改变状态转换的规则。然而它也有一些缺点：

			- 对表的查找通常不如（虚）函数调用效率高。
			- 用统一的、表格的形式表示转换逻辑使得转换准则变得不够明确而难以理解。
			- 通常难以加入伴随状态转换的一些动作。表驱动的方法描述了状态和它们之间的转换，但必须扩充这个机制以便在每一个转换上能够进行任意的计算。

		- State模式对于状态相关的行为进行建模，而表驱动的方法这种鱼定义状态转换。

	- 创建和销毁State对象

		- 一个常见的值得考虑的实现上的权衡是，究竟是（1）仅当需要State对象时才创建它们并随后销毁它们，还是（2）提前创建它们并且始终不销毁它们。

	- 使用动态继承

		- 改变一个响应特定请求的行为可以用在运行时刻改变这个对象的类的办法实现，但这在大多数面向对象程序设计语言中都是不可能的。

- 相关模式

	- Flyweight模式解释了何时以及怎样共享状态对象
	- 状态对象通常是Singleton

### STRATEGY(策略)

- 意图

	- 定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。

- 别名

	- 政策（Policy）

- 动机

	- 我们可以定义一些类来封装不同的算法，从而避免这些问题。

- 适用性

	- 许多相关的类仅仅是行为有异。“策略”提供一种用多个行为中的一个行为来配置一个类的方法。
	- 需要使用一个算法的不同变体。
	- 算法使用客户不应该知道的数据。可使用策略模式以避免暴露复杂的、与算法相关的数据结构。
	- 一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现。将相关的条件分支移入它们各自的Strategy类中代替这些语句。

- 结构

	- 

- 参与者

	- Stragegy(策略)

		- 定义所支持的算法的公共接口。Context使用这个接口来调用某ConcreteStragegy定义的算法。

	- ConcreteStrategy(具体策略)

		- 以Strategy接口实现某具体算法

	- Context(上下文)

		- 用一个ConcreteStrategy对象来配置
		- 维护一个对Strategy对象的引用。
		- 可定义一个接口来让Stategy访问它的数据。

- 协作

	- Strategy和Context相互作用以实现选定的算法。当算法被调用时，Context可以将该算法所需要的所有数据都传递给该Strategy。或者，Context可以将自身作为一个参数传递给Strategy操作。这就让Strategy在需要时可以回调Context。
	- Context将它的客户的请求转发给它的Strategy。客户通常创建并传递一个ConcreteStragegy对象给该Context；这样客户仅与Context交互。通常有一系列的ConcreteStrategy类可供客户从中选择。

- 效果

	- 优点

		- 相关算法系列

			- Strategy类层次为Context定义了一系列可供重用的算法和行为。继承有助于析取出这些算法中的公共功能。

		- 一个替代继承的方法

			- 提供了另一种支持多种算法或行为的方法。但不能动态地改变算法。最后你得到一堆相关的类，它们的唯一差别是它们所使用的算法或行为。
			- 将算法封装在独立的Strategy类中使得你可以独立于其Context改变它，使它易于切换、易于理解、易于扩展。

		- 消除了一些条件语句

			- Strategy模式提供了用条件语句选择所需的行为以外的另一种选择。当不同的行为堆砌在一个类中时，很难避免使用条件语句来选择合适的行为。
			- 将行为封装在一个个独立的Strategy类中消除了这些条件语句。

		- 实现的选择

			- Strategy模式可以提供相同行为的不同实现。
			- 客户可以根据不同时间/空间权衡取舍要求从不同策略进行选择。

	- 缺点

		- 客户必须了解不同的Strategy

			- 一个客户要选择一个合适的Strategy就必须知道这些Strategy有何不同。此时可能不得不向客户端暴露具体实现的问题。
			- 因此仅当这些不同行为变体与客户相关的行为时，才需要使用Strategy模式。

		- Strategy和Context之间的通信开销

			- 无论各个ConcreteStrategy实现的算法是简单还是复杂，它们都共享Strategy定义的接口。
			- 因此很可能某些ConcreteStrategy不会都用到所有通过这些接口传递给它们的信息。

		- 增加对象的数目

			- Strategy增加了一个应用中的对象的数目。
			- 有时你可以将Strategy实现为可供各Context共享的无状态的对象来减少这一开销。任何其余的状态都由Context维护。

- 实现

	- 定义Strategy和Context接口

		- Strategy和Context接口必须使得ConcreteStrategy能够有效的访问它所需要的Context中的任何数据，反之亦然。
		- 一种方法时让Context将数据放在参数中传递给Strategy操作。
		- 另一种方法时让Context自身作为一个参数传递给Strategy，该Strategy再显式地向该Context请求数据。

	- 将Strategy作为模板参数

		- 在C++中，可利用模板机制用一个Strategy来配置一个类。然后这种技术仅当下面条件满足时才可以使用。

			- （1）可以在编译时选择Strategy
			- （2）它不需在运行时改变。

	- 使Strategy对象成为可选的

		- 如果即使在不使用额外的Strategy对象的情况下，Context也还有意义的话，那么它还可以被简化。
		- Context在访问某Strategy前先检查它是否存在，如果有，那么就使用它。
		- 如果没有那么Context执行缺省的行为。这种方法的好处是客户根本不需要处理Strategy对象，除非它们不喜欢缺省的行为。

- 相关模式

	- Flyweight

		- Stategy对象经常是很好的轻量级对象。

### TEMPLATE METHOD(模板方法)

- 意图

	- 在一个方法中定义算法的骨架，而一些步骤延迟到子类中，模板方法在子类不改变数据结构的情况下，重新定义算法中的某些步骤。

- 动机

	- 一个模板方法用一些抽象的操作定义一个算法，而子类将重定义这些操作以提供具体行为。

- 适用性

	- 一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现。
	- 各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复。
	- 控制子类扩展。

- 结构

	- 

- 参与者

	- AbstractClass（抽象类）

		- 定义抽象的原语操作（primitive operation），具体的子类将重定义它们以实现一个算法的各步骤。
		- 实现一个模板方法，定义一个算法框架。该模板方法不仅调用原语操作，也调用定义在AbstractClass或其他对象中的操作。
		- ConcreteClass(具体类)

- 协作

	- ConcreteClass靠AbstractClass来实现算法中不变的步骤

- 效果

	- 模板方法是一种代码复用的基本技术。它在类库中尤为重要，它们提取了类库中的公共行为。
	- 模板方法导致一种反向的控制结构，这种结构有时被称为“好莱坞法则”，即“别找我们，我们找你”这指的是一个父类调用一个子类的操作，而不是相反。
	- 模板方法调用下列类型的操作

		- 具体的操作（ConcreteClass或对客户类的操作）
		- 具体的AbstractClass的操作
		- 原语操作
		- Factory Method
		- 钩子操作（hook operations），它提供了缺省的行为，子类可以在必要时进行扩展。一个钩子操作在缺省操作通常是一个空操作。

- 实现

	- 使用C++访问控制

		- 在C++中，一个模板方法调用的原语操作可以被定义为保护成员。这保证它们只被模板方法调用。
		- 必须重定义的原语操作续定义为纯虚函数。模板方法自身不需被重定义，因此可以将模板方法定义为以外非虚函数。

	- 尽量减少原语操作

		- 定义模板方法的一个重要目的是尽量减少一个子类具体实现该算法时必须重定义的那些原语操作的数目。需要重定义的操作越多，客户程序就越冗长。

	- 命名约定

		- 可以给应被重定义的那些操作的名字加上一个前缀以识别它们。

- 相关模式

	- Factory Method模式

		-  常被模板方法调用。

	- Strategy

		- 模板方法使用继承来改变算法的一部分。Strategy使用委托来改变整个算法。

### VISITOR(访问者)

- 意图

	- 表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。

- 动机

	- 使用Viitor模式,必须定义两个类层次：一个对应于操作的元素（Node层次）另一个对应于定义对元素操作的访问者（Node Visitor层次）.

- 适用性

	- 一个对象结构包含很多类对象，它们有不同的接口，而你想对这些对象实施一些依赖于具体类的操作。
	- 需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而你想避免让这些操作“污染”这些对象的类。

		- Visitor使得你可以将相关的操作集中起来定义在一个类中。当该对象结构被很多应用共享时，用Visitor模式让每个应用仅包含需要用到的操作。

	- 定义对象结构的类很少改变，但经常需要在此结构上定义新的操作。改变对象结构类需要重定向对所有访问者的接口，这可能需要很大的代价。

		- 如果对象结构类经常改变，那么可能还是在这些类中定义这些操作较好。

- 结构

	- 

- 参与者

	- Visitor(访问者)

		- 为该对象结构中ConcreteElement的每个类声明一个Visit操作。该操作的名字和特征标识了发送Visit请求給该访问者的那个类。这使得访问者可以确定正被访问元素的具体的类。这样访问者就可以通过该元素的特定接口直接访问它。

	- ConcreteVisitor(具体访问者)

		- 实现么个由Visitor声明的操作。每个操作实现本算法的一部分，而该算法片段乃是对应于结构对象的类。ConcreteVisitor为该算法提供了上下文并存储它的局部状态。这一状态常常在遍历该结构的过程中累积结果。

	- Element(元素)

		- 定义一个Accept操作，它以一个访问者为参数

	- ConcreteElement(具体元素)

		- 实现Accept操作，该操作以一个访问者为参数。

	- ObjectStructure(对象结构)

		- 能枚举它的元素
		- 可以提供一个高层的接口以允许该访问者访问它的元素。
		- 可以是一个复合或是一个集合

- 协作

	- 一个使用Visitor模式的客户必须创建一个ConcreteVisitor对象，然后遍历该对象结构，并用该访问者访问每一个元素。
	- 当一个元素被访问时，它调用对应于它的类的Visitor操作。如果必要，该元素将自身作为这个操作的一个参数以便该访问者访问它的状态。

- 效果

	- 优点

		- 访问者模式使得易于增加新的操作

			- 访问者使得增加依赖于复杂对象结构的构件的操作变得容易了。仅需增加一个新的访问者即可在一个对象结构上定义一个新的操作。相反，如果每个功能都分散在多个类之上的话，定义新的操作时必须修改每一类。

		- 访问者集中相关的操作而分离无关的操作

			- 相关的行为不是分布在定义该对象结构的各个类上，而是集中在一个访问者中。无关行为却被分别放在它们各自的访问者子类中。
			- 这就既简化了这些元素的类，也简化了在这些访问者中定义的算法。所有与它的算法相关的数据结构都可以被隐藏在访问者中。

	- 缺点

		- 增加新的ConcreteElement类很困难

			- Visitor模式使得难以增加新的Element的子类。每添加一个新的ConcreteElement都要在Visitor中添加一个新的抽象操作，并在每一个ConcreteVisitor类中实现对应的操作。有时可以在Visitor中提供一个缺省的实现，这一实现可以被大多数的ConcreteVisitor继承，但这与其说是一个规律还不如说是一种例外。

		- 通过类层次进行访问

			- 一个迭代器可以通过调用节点对象的特定操作来遍历整个对象结构，同时访问这些对象。但是迭代器不能对具有不同元素类型的对象结构进行操作。

		- 积累状态

			- 当访问者访问对象结构中的每一个元素时，它可能会积累状态。如果没有访问者，这一状态将作为额外的参数传递给进行遍历的操作，或者定义为全局部变量

		- 破坏封装

			- 访问者方法假定ConcreteElement接口的功能足够强，足以让访问者进行它们的工作。结果是，该模式常常迫使你提供访问元素内部状态的公共操作，这可能会破坏它的封装性。

- 实现

	- 双分派（Double-dispatch）

		- 访问者模式允许你不改变类即可有效地增加其上的操作。为达到这一效果使用了一种称为双分派（double-dispatch）的技术。

	- 谁负责遍历对象结构

		- 一个访问者必须访问这个对象结构的每一个元素。我们可以将遍历的责任放到下面三个地方中的任意一个：对象结构中，访问者中，或一个独立的迭代器对象中。

			- 通常由对象结构负责迭代。一个集合只需对它的元素进行迭代，并对每一个元素调用Accept操作。而一个复合通常让Accept操作遍历该元素的各子构建并对它们中的每一个递归地调用Accept。
			- 另一个解决方案是使用一个迭代器来访问各个元素。
			- 甚至可以将遍历算法放在访问者中，尽管这样将导致每一个聚合ConcreteElement，在每一个ConcreteVisitor中都要复制遍历的代码。

### 综合对比

- 封装变化

	- Strategy

		- 一个Strategy对象封装一个算法

	- State

		- 一个State对象封装一个

	- Meditator

		- 一个Meditator对象封装对象间的协议

	- Iterator

		- 一个Iterator对象封装访问和遍历一个聚合对象中的各个构件的方法。

- 通信应该被封装还是被分布

	- Mediator和Observer

		- Mediator和Observer是相互竞争的模式。它们之间的区别是，Observer通过Observer和Subject对象分布通信，而Mediator对象则封装了其他对象间的通信。
		- 在Observer模式中，不存在封装一个约束的单个对象，而必须是由Observer和Subject对象相互协作来维护这个约束。通信模式由观察者和目标连接的方式决定：

			- 一个目标的目的是集中而不是分布，并且有时一个目标的观察者也是另一个观察者的目标。
			- Mediator模式的目的是集中而不是分布。它将维护一个约束的职责直接放在一个中介者中。

		- 相对于Observer,Mediator中的信息流更容易理解。观察者和目标通常在它们被创建之后很快即被连接起来，并且很难看出此后它们在程序中是如何连接的。

- 对发送者和接收者解耦

	- 当合作的对象直接相互引用是，它们变得相互依赖，这可能会对一个系统的分层和复永性产生负面影响。
	- 命令、观察者、中介者和职责链等模式都涉及如何对发送者和接收者解耦，但它们又各有不同的权衡考虑。
	- Command

		- 命令模式使用一个Command对象来定义一个发送者和一个接收者之间的绑定关系，从而支持解耦。
		- 可以复用Command对象，用不同的发送者参数化一个接收者。
		- 虽然Command模式描述了避免使用生成子类的实现技术，名义上每一个发送者-接收者都需要一个子类。

	- Observer

		- 观察者通过定义一个接口来通知目标中发生的改变，从而将发送者（目标）与接收者（观察者）解耦。
		- 观察者模式中的Subject和Observer接口是为了处理Subject 的变化而设计的，因此对象间有数据依赖时，最好用观察者模式来对它们进行解耦。
		- 中介者模式可以减少一个系统中的子类的生成，因为它将通信行为集中到一个类中而不是将其分散在各个子类中。
		- 然而，特定的分发策略通常会降低类型安全性。

## 复合模式

### 结合两个或以上的模式，组成一个解决方案，解决一再发生的一般性问题。

## 设计原则

### 找出应用可能需要的变化之处，把它们独立出来，不要和那些不需要混在一起

### 针对接口编程，而不是针对实现编程

- 针对接口编程的真正意思是，针对超类型编程

### 为交互对象之间松耦设计而努力

### 类应该对扩展开放，对修改关闭

### 要依赖抽象，不要依赖具体类

### 最少知识原则，只对你的密友谈话

### 好莱坞原则

- 别调用（打电话给）我们，我们会调用（打电话给）你

### 一个类应该只有一个引起变化的原因

## 六大设计原则

### 单一职责原则

### 里式替换原则

- 子类必须完全实现服务类的方法
- 子类可以有自己的个性
- 覆写或实现父类的方法时输入参数可以被放大
- 覆写或实现父类的方法时输出结果可以被缩小

### 依赖倒置原则

- 高层模块不应该依赖低层模块，两者都应该依赖其抽象。
- 抽象不应该依赖细节
- 细节应该依赖抽象

### 接口隔离原则

### 迪米特法则

- 也称为最少知识原则
- 只和朋友交流

### 开闭原则

## OO原则

### 封装变化

### 多用组合，少用继承

### 针对接口编程,不针对实现编程

### 为交互对象之间松耦设计而努力

### 对扩展开放，对修改关闭

### 依赖抽象，不要依赖具体类

### 只和朋友交谈

### 别找我，我会找你

### 一个类应该只有一个改变的理由

